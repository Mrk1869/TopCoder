import math
import string

class MostProfitable:
    def bestItem(self, costs, prices, sales, items):

        max_index = -1
        max_benefit = 0
        for i in range(len(items)):
            benefit = (prices[i] - costs [i]) * sales[i]
            if benefit > max_benefit:
                max_benefit = benefit
                max_index = i

        res = ""
        if max_index >= 0:
            res = items[max_index]

        return res

# BEGIN KAWIGIEDIT TESTING
# Generated by KawigiEdit-pfx 2.1.9
import sys
import time
def KawigiEdit_RunTest(testNum, p0, p1, p2, p3, hasAnswer, p4):
    sys.stdout.write(str("Test ") + str(testNum) + str(": [") + str("{"))
    for i in range(len(p0)):
        if (i > 0):
            sys.stdout.write(str(","))

        sys.stdout.write(str(p0[i]))

    sys.stdout.write(str("}") + str(",") + str("{"))
    for i in range(len(p1)):
        if (i > 0):
            sys.stdout.write(str(","))

        sys.stdout.write(str(p1[i]))

    sys.stdout.write(str("}") + str(",") + str("{"))
    for i in range(len(p2)):
        if (i > 0):
            sys.stdout.write(str(","))

        sys.stdout.write(str(p2[i]))

    sys.stdout.write(str("}") + str(",") + str("{"))
    for i in range(len(p3)):
        if (i > 0):
            sys.stdout.write(str(","))

        sys.stdout.write(str("\"") + str(p3[i]) + str("\""))

    sys.stdout.write(str("}"))
    print(str("]"))
    obj = MostProfitable()
    startTime = time.clock()
    answer = obj.bestItem(p0, p1, p2, p3)
    endTime = time.clock()
    res = True
    print(str("Time: ") + str((endTime - startTime)) + str(" seconds"))
    if (hasAnswer):
        print(str("Desired answer:"))
        print(str("\t") + str("\"") + str(p4) + str("\""))

    print(str("Your answer:"))
    print(str("\t") + str("\"") + str(answer) + str("\""))
    if (hasAnswer):
        res = answer == p4

    if (not res):
        print(str("DOESN'T MATCH!!!!"))
    elif ((endTime - startTime) >= 2):
        print(str("FAIL the timeout"))
        res = False
    elif (hasAnswer):
        print(str("Match :-)"))
    else:
        print(str("OK, but is it right?"))

    print(str(""))
    return res

all_right = True


# ----- test 0 -----
p0 = [100,120,150,1000]
p1 = [110,110,200,2000]
p2 = [20,100,50,3]
p3 = ["Video Card","256M Mem","CPU/Mobo combo","Complete machine"]
p4 = "Complete machine"
all_right = KawigiEdit_RunTest(0, p0, p1, p2, p3, True, p4) and all_right
# ------------------

# ----- test 1 -----
p0 = [100]
p1 = [100]
p2 = [134]
p3 = ["Service, at cost"]
p4 = ""
all_right = KawigiEdit_RunTest(1, p0, p1, p2, p3, True, p4) and all_right
# ------------------

# ----- test 2 -----
p0 = [38,24]
p1 = [37,23]
p2 = [1000,643]
p3 = ["Letter","Postcard"]
p4 = ""
all_right = KawigiEdit_RunTest(2, p0, p1, p2, p3, True, p4) and all_right
# ------------------

# ----- test 3 -----
p0 = [10,10]
p1 = [11,12]
p2 = [2,1]
p3 = ["A","B"]
p4 = "A"
all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, True, p4) and all_right
# ------------------

if (all_right):
    print(str("You're a stud (at least on the example cases)!"))
else:
    print(str("Some of the test cases had errors."))

# PROBLEM STATEMENT
# When selling goods, it is important to know exactly how much it costs to acquire each item.  A number of distributed costs, such as marketing often make this difficult, but not impossible.  If a business can figure out how much an item costs, with some accuracy, then it can easily calculate the profit margins for the item.  This information, combined with sales figures, can be used to determine which items are the most important to a business.  In this problem you will be given the costs, prices, and number of sales for a number of items.  Each element of costs represents the total costs accrued from selling a single item.  The corresponding elements (ones with the same index) of prices and sales represent the prices at which single items are sold, and the number of sales of each item that have occurred in some time period, respectively.  You are to return the name of the item (the corresponding element of items) that provides the business with the most profits.  If there is a tie for the most profitable item, return the one that comes earliest in items (lowest index).  If no item provides the business with positive profits you should return the empty string.
#
#
#
# DEFINITION
# Class:MostProfitable
# Method:bestItem
# Parameters:tuple (integer), tuple (integer), tuple (integer), tuple (string)
# Returns:string
# Method signature:def bestItem(self, costs, prices, sales, items):
#
#
# CONSTRAINTS
# -costs, prices, sales, and items will all contain the same number of elements.
# -costs, prices, sales, and items will contain between 1 and 50 elements, inclusive.
# -Each element of costs and prices will be between 1 and 1,000,000, inclusive.
# -Each element of sales will be between 0 and 1,000, inclusive.
# -Each element of items will have between 1 and 50 characters, inclusive.
# -Each character of each element of items will have ASCII value between 32 and 126, inclusive.  (All of the characters that can be easily made with a regular keyboard.)
#
#
# EXAMPLES
#
# 0)
# {100,120,150,1000}
# {110,110,200,2000}
# {20,100,50,3}
# {"Video Card","256M Mem","CPU/Mobo combo","Complete machine"}
#
# Returns: "Complete machine"
#
# This business makes 200 on video cards, loses 1000 on memory, makes 2500 on CPU/Mobo combos, and makes 3000 on complete machines.  Since 3000 is the highest, you should return "Complete machine".
#
# 1)
# {100}
# {100}
# {134}
# {"Service, at cost"}
#
# Returns: ""
#
# The only product given is sold at cost, so there are no items which give positive profit.
#
# 2)
# {38,24}
# {37,23}
# {1000,643}
# {"Letter","Postcard"}
#
# Returns: ""
#
# 3)
# {10,10}
# {11,12}
# {2,1}
# {"A","B"}
#
# Returns: "A"
#
# END KAWIGIEDIT TESTING
#Powered by KawigiEdit-pfx 2.1.9!
